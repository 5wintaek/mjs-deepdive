# 23장 실행 컨텍스트

## 23-1. 소스코드의 타입

- ECMA Script는 소스코드를 4가지 타입으로 구분한다.
- 각 타입은 실행 컨텍스트를 생성한다.

### 전역 코드

- 전역 코드는 전역 변수를 관리하기 위한 전역 스코프를 생성한다.
- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야한다.
- 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.

### 함수 코드

- 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다.
- 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
- 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.

### eval 코드

- strict mode에서 독자적인 스코프를 생성한다.
- eval 코드가 평가되면 eval 실행 컨텍스트가 생서된다.

### 모듈 코드

- 모듈별로 독립적인 모듈 스코프를 생성한다.
- 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

## 23-2. 소스코드의 평가와 실행

- 모든 소스코드는 평가와 실행단계로 나눠 처리된다.
- 평가 과정
  - 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 변수나 함수 식별자를 키로 하여 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.
- 실행 단계
  - 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다.(런타임)
  - 실행에 필요한 정보는 스코프에서 검색해서 취득한다.
  - 실행 결과는 다시 스코프에 등록되나.

## 23-3. 실행 컨텍스트의 역할

### 1. 전역 코드의 평가

- 실행을 위한 준비를 하는 단계
- 선언문만 먼저 시행한다.
- 전역 스코프에 식별자를 등록하고 초기화 등을 한다.
- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티, 메서드가 된다.

### 2. 전역 코드의 실행

- 전역 코드가 순차적으로 실행된다. (런타임)
- 이때 변수에 값이 할당되고 함수가 호출된다.
- 함수가 호출되면 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.

### 3. 함수 코드의 평가

- 함수 코드를 실행하기 위한 준비를 한다.
- 매개변수와 지역 변수 선언문이 먼저 실행되고, 지역 스코프에 이들을 등록한다.
- arguments 객체가 생성되어 지역 스코프에 등록된다.
- this 바인딩도 결정된다.

### 4. 함수 코드의 실행

- 함수 코드가 순차적으로 실행된다. (런타임)
- 메서드 호출이 있다면 식별자를 스코프 체인을 통해 검색하여 실행한다.
- 함수 코드의 실행이 완료되었다면 전역 코드 실행을 이어간다.

> 이처럼, 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값, 그리고 코드 실행순서 등이 실행 컨텍스트에 의해 관리되어야한다.

즉 실행 컨텍스트란, 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

- 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리한다.
- 스코프는 중첩 관계에 의해 스코프 체인을 형성하여 한다. 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.
- 현재 실행중인 코드의 실행 순서를 변경할 수 있어야하고, 다시 되돌아 갈수 있어야한다.
- 렉시컬 환경 : 식별자와 스코프 관리
- 실행컨텍스트 스택 : 코드 실행 순서 관리

## 23-4. 실행 컨텍스트 스택

- 실행 컨텍스트는 stack 자료 구조로 관리된다.
- 코드의 실행 순서를 관리한다.
- 실행중인 실행 컨텍스트 (running execution context): 스택 최상단에 있는 실행 컨텍스트가 현재 실행중인 코드의 실행 컨텍스트다.

## 23-5. 렉시컬 환경

- 스코프와 식별자를 관리한다.
- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 렉시컬 환경은 2개의 컴포넌트로 구성된다.
  - 환경 레코드 : 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리한다.
  - 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킨다. 이 참조를 통해 스코프 체인을 구현한다.

## 23-6. 실행 컨텍스트의 생성과 식별자 검색 과정

### 23.6.1 전역 객체 생성

- 전역 코드가 평가하되기 이전에 생성된다.
- 빌트인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체와 실행 환경에 따른 호스트 객체가 전역 객체에 추가된다.
- 전역 객체도 Object.prototype을 상속받는다.

### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 전역 코드를 평가한다.

#### 전역 코드 평가 순서

- 전역 실행 컨텍스트 생성
- 전역 렉시컬 환경 생성
  - 전역 환경 레코드 생성
    - 객체 환경 레코드 생성
    - 선언적 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성

- 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

#### 2. 전역 렉시컬 환경 생성

- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.

#### 2.1 전역 환경 레코드 생성

- 전역 렉시컬 환경을 구성하는 컴포넌트 중 하나인 전역 환경 레코드를 생성한다.
- 전역 스코프, 전역 객체의 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 제공한다,.
- ES6부터 let, const 선언 전역 변수와 구분하고 관리하기 위해 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성하고 있다.
- 객체 환경 레코드 : var 키워드 선언 전역 변수, 함수선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리한다.
- 선언적 환경 레코드 : let, const 키워드로 선언한 전역 변수를 관리한다.

#### 2.1.1 객체 환경 레코드 생성

- BindingObject라는 객체와 연결된다. 이는 전역 객체 생성단계에서 생성된 전역 객체이다.
- 전역 코드 평가 과정에서 var 키워드로 선언된 전역변수와 함수 선언문으로 정의된 전역 함수는 이 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
- var 키워드로 선언한 변수는, 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한다음, 값을 undefined로 초기화한다. 이로 인해 실행단계에서 변수 선언문 이전에도 참조할 수 있는 것이다.
- 함수 선언문으로 정의된 함수의 경우, 마찬가지로 BindingObject를 통해 전역 객체에 키로 등록하고, 생성된 함수 객체를 **즉시** 할당한다. 함수 선언문 이전에 함수를 호출할 수 있는 이유이다.

#### 2.1.2 선언적 환경 레코드 생성

- let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다. 이들은 전역객체의 프로퍼티가 되지 않는다.
- window.y와 같이 전역 객체의 프로퍼티로서 참조할 수 없다.
- const 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다.
- 런타임에 실행 흐름이 변수선언문에 도달하기 전까지 일시적 사각지대에 빠지게 된다.

#### 2.2 this 바인딩

- 전역환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.
- 일반적으로 전역 객체가 바인딩된다.
- this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.

#### 2.3 외부 렉시컬 환경에 대한 참조 결정

- 전역 코드의 상위 스코프는 없으므로, 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 null이 할당된다.
- 전역 렉시컬 환경이 스코프 체인의 종점에 존재하는 이유이다.

### 23.6.3 전역 코드 실행

- 코드를 실행하면서 식별자 결정단계를 거친다. 식별자를 검색할 때는 실행중인 실행컨텍스트에서 식별자를 검색하기 시작한다.
- 만약 실행 중인 실행컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 상위 스코프로 이동하여 식별자를 검색한다.
- 검색할 수 없는 경우 참조 에러를 발생시킨다.

### 23.6.4 foo 함수 코드 평가

- 함수가 호출되면 전역 코드의 실행을 일시 중단하고 함수 내부로 코드의 제어권이 이동한다.
- 그리곤 함수코드의 평가가 시작된다.

#### 함수 코드의 평가 단계

- 함수 실행 컨텍스트 생성
- 함수 렉시컬 환경 생성
  - 함수 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

#### 1. 함수 실행 컨텍스트 생성

- 호출된 함수의 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시된다.
- 스택의 최상위가 해당 함수의 실행 컨텍스트가 된다.

#### 2. 함수 렉시컬 환경 생성

- 함수 렉시컬 환경을 생성하고 함수 실행 컨텍스트에 바인딩한다.

#### 2.1 함수 환경 레코드 생성

- 함수 환경 레코드는 함수 렉시컬 환경을 구성하는 컴포넌트 중 하나이다.
- 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

#### 2.2 this 바인딩

- [[ThisValue]] 내부 슬롯에 this가 바인딩된다.

#### 2.3 외부 렉시컬 환경에 대한 참조 결정

- 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
- 함수 객체를 생성할 때 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 함수 객체의 내부슬롯 [[Environment]]에 저장한다.

### 23.6.5 foo 함수 코드 실행

- 매개변수엔 인수가 할당되고 함수가 호출된다. 이때 식별자 결정을 위해 렉시컬 환경에서 식별자를 검색하기 시작한다.
- 함수 환경 내에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조를 따라 식별자를 검색하여 일치하는 것이 있으면 할당한다.

### 23.6.6 bar 함수 코드 평가

- 내부 함수가 호출되면 다시 내부 함수로 코드 제어권이 이동한다. 마찬가지로 내부 함수의 평가와 실행이 이뤄진다.

### 23.6.7 bar 함수 코드 실행

- 메서드 실행 시 식별자를 스코프체인에서 마찬가지로 검색하며, 없다면 스코프체인을 타고 올라가 찾는다.
- console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.

### 23.6.8 bar 함수 코드 실행 종료

- 내부 함수의 실행 컨텍스트 스택이 팝되고 외부함수의 실행컨텍스트가 다시 스택에서 최상위 포지션이 된다.
- 내부 함수의 실행이 종료되었다고 해서 내부 함수 bar의 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 실행 컨텍스트에 의해 참조되지만 독립적인 객체이어서, 누군가 참조하고 있다면 bar 렉시컬 환경은 소멸되지 않는다.(클로저)

### 23.6.9 foo 함수 코드 실행 종료

- 외부함수도 종료되고 실행컨텍스트 스택에서 빠진다.
- 다시 전역 실행 컨텍스트가 실행중인 실행 컨텍스트가 된다.

### 23.6.10 전역 코드 실행 종료

- 끝까지 코드를 실행하고 전역 실행 컨텍스트도 팝되어 사라진다.
- 최종적으로, 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다.

## 23-7. 실행 컨텍스트와 블록 레벨 스코프

- var 키워드 선언한 변수는 함수 코드 블록만 지역 스코프로 인정한다.
- 하지만 let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정한다. (블록 레벨 스코프)
- if문(내부에 let 키워드로 선언된 변수가 있다면)과 같은 블록이 생성되면 새로운 렉시컬 환경을 생성한다.
- for문에서 let을 사용하였다면 코드블록이 반복실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다.
  - for문 상위에 있는 스코프가 식별자를 유지하게끔 독립적인 렉시컬 환경을 생성한다.
