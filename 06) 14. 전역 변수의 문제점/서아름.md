# 14. 전역 변수의 문제점

> 전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.

## 📚 변수의 생명 주기

> 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체/ 메모리 공간을 식별하기 위한 이름

- 변수 생명 주기
  - 메모리 공간이 확보된 시점 ~ 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지 !
- `전역 변수` 생명 주기
  - 애플리케이션 생명 주기와 동일
  - 🌟 선언문의 위치와 관계없이, 런타임 이전 단계에서 **자바스크립트 엔진에 의해 먼저 실행** 🌟
- `지역 변수` 생명 주기
  - 험수 호출 시 생성
  - 함수 종료 시 소멸
  - **함수의 생명 주기와 일치**
- **지역 변수가 함수보다 오래 생존하는 경우 !**
  - 누군가 메모리 공간을 참조하고 있는 경우
  - 가비지 콜렉터에 의해 해제되지 않고 메모리가 확보된 상태로 남아있게 됨 (스코프도 마찬가지)

<br />

### 🔖 호이스팅

- 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 스코프 단위로 동작
- **전역 변수** 호이스팅
  - 전역 변수 선언이 **전역 스코프의 선두로 끌어 올려진 것처럼 동작**
  - 즉, 전역 변수는 전역 전체에서 유효함
- **지역 변수** 호이스팅
  - 지역 변수 선언이 **지역 스코프의 선두로 끌어 올려진 것처럼 동작**
  - 즉, 지역 변수는 함수 전체에서 유효함

```jsx
var x = "global";

function foo() {
  console.log(x); // 1. undefined
  var x = "local";
}

foo();
console.log(x); // 2. global
```

- foo() 함수 내부 콘솔에서 undefined가 찍힘
  - 지역 변수 x는 콘솔이 찍히는 시점에 이미 선언되었고, undefined로 초기화되어 있음
  - 지역 변수는 함수 전체에서 유효
  - 변수 할당문 실행 이전까지 undefined를 가짐

<br />

## 📚 전역 변수의 생명 주기

- 전역 코드는 명시적 호출 없이 실행
- 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행
- **var** 키워드로 선언한 전역변수는 **전역 객체의 프로퍼티**가 됨
  - 🌟 이는 `전역 변수 생명주기`가 `전역 객체 생명 주기`와 `동일`하다는 것을 의미 🌟

<br />

### 🔖 전역 객체

- 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
- 서버 사이드 환경(Node.js)에서의 전역 객체
  - global 객체
- **클라이언트** 사이드 환경(브라우저)에서의 전역 객체
  - **window**
  - 즉, var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티임
  - 전역 객체 window는 웹 페이지를 닫기 전까지 유효 → var 키워드로 선언한 전역 변수 역시 웹 페이지를 닫기 전까지 유효함
- 🌟 **var 키워드로 선언한 전역 변수 생명주기 === 전역 객체의 생명 주기** 🌟

<br />

## 📚 전역 변수 문제점

### 1️⃣ 암묵적 결합

- 모든 코드가 어디서든 전역 변수를 참조하고 변경할 수 있는 것
- 변수의 유효 범위가 클수록 가독성 저하 및 의도치 않은 상태 변경의 위험성 증가

### 2️⃣ 긴 생명 주기

- 전역 변수는 생명 주기가 길기 때문에, 오랜 시간 메모리 리소스를 소비 + 전역 변수의 상태를 변경할 수 있는 시간도, 기회도 많음
- var 키워드는 변수의 중복 선언 허용
  - 생명 주기가 긴 전역 변수는 변수 이름 중복될 가능성 → 의도치 않은 재할당 유발

### 3️⃣ 스코프 체인 상의 종점에 존재

- 전역 변수의 검색 속도가 가장 느림
  - 변수를 검색할 때 전역 변수가 가장 마지막에 검색되기 때문

### 4️⃣ 네임스페이스 오염

- 하나의 전역 스코프 공유
  - 파일이 분리되어 있다 해도 하나의 스코프를 공유하기 때문에 동일한 이름으로 전역 변수나 전역 함수가 존재할 경우 side effect 발생

<br />

## 📚 전역 변수의 사용 억제하는 방법

- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용할 것
- 변수의 스코프는 좁을 수록 좋음

### 1️⃣ 즉시 실행 함수

- 함수 정의와 동시에 호출되는 함수, 단 한 번만 호출됨

```jsx
// 모든 코드를 즉시 실행 함수로 감싼 모습
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
})();

console.log(foo); // ReferenceError: foo is not defined
```

- **🌟 모든 코드를 즉시 실행 함수로 감싸면 `모든 변수는 즉시 실행 함수의 지역 변수`가 됨 🌟**
- 전역 변수 생성 X → 라이브러리 등에 자주 사용됨

<br />

### 2️⃣ 네임스페이스 객체

```jsx
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = "Lee";

console.log(MYAPP.name); // Lee
```

- 전역에 네임스페이스 담당 객체 생성
- 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
- 네임스페이스 객체를 프로퍼티로 추가해서 계층적 구성 가능
- 식별자 충돌 방지 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용 ❌

<br />

### 3️⃣ 모듈 패턴

```jsx
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
  return {
    // 클로저
    increase() {
      return ++num;
    },
    // 클로저
    decrease() {
      return --num;
    },
  };
})();

// private 변수는 외부로 노출되지 X
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

- 클래스를 모방해서 관련있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든 것
- 전체 애플리케이션 중 일부를 독립된 코드로 분리한 것
- `클로저`를 기반으로 동작
  - 이미 실행이 종료된 함수의 변수나 함수를 참조할 수 있는 링크를 가진 내적 함수
  
  - 대체 이게 무슨 말인지 찾아봄 !!
  - 외부 함수보다 **중첩 함수**가 더 오래 유지되는 경우, **이미 생명 주기가 종료된 외부 함수의 변수를 참조**할 수 있는데, 이런 중첩 함수 자체를 **클로저**라고 함
  - 핵심은 스코프를 통해 변수 접근 범위를 단는것
  - 변수가 선언된 위치가 중요함
- 전역 변수의 억제는 물론 `캡슐화`까지 구현 가능
  - 프로퍼티(객체의 상태) + 메서드(프로퍼티를 참조하고 조작할 수 있는동작)을 하나로 묶는 것
  - 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 함 (정보 은닉)

<br />

### 4️⃣ ES6

- 파일 자체의 독자적인 모듈 스코프를 제공하여 전역 변수 사용 불가 ❌
- var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아님 ❌

```jsx
<script type="module" scr="lib.mjs"></script>
<script type="module" scr="app.mjs"></script>
```

- script 태그에 type=”module” 어트리뷰트 추가 시 모듈로서 동작, 확장자는 mjs 권장
