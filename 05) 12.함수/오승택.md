## 함수

### Remind

> 리터럴이란 ?

JavaScript에서 리터럴(literal)은 "값"을 표현하는 고정된 방식입니다. 리터럴은 프로그램 소스 코드에서 직접 값으로 사용되는 고정된 표현식을 말합니다. 이 값은 데이터의 타입에 따라 다르게 표현될 수 있습니다. 리터럴은 변수가 아니며, 변수를 초기화하거나 값으로 사용할 수 있는 상수 표현입니다.

> 표현식과 문의 차이점은 ?

표현식은 값을 생성하거나 반환하는 코드의 조각입니다. 표현식은 하나의 값으로 평가되며, 그 값을 사용하여 변수에 할당하거나 다른 표현식의 일부로 사용할 수 있습니다.

리터럴 표현식

```js
5;
("hello");
true;
```

산술 표현식

```js
3 + 4;
10 * 2;
```

문은 프로그램의 작업을 수행하는 독립적인 코드 단위입니다. 문은 특정한 행동을 지시하며, 표현식을 포함할 수 있습니다. 문은 프로그램의 흐름을 제어하는 데 사용됩니다.

변수 선언문

```js
let x = 10; // 변수 선언문은 'x = 10'이라는 표현식을 포함
```

함수 선언문

```js
function greet() {
  console.log("Hello");
}
```

**_표현식과 문의 차이점_**

**값의 평가**

표현식: 하나의 값으로 평가됩니다.
문: 특정한 작업을 수행하며, 값으로 평가되지 않습니다 (하지만 문 내에 표현식이 포함될 수 있습니다).

**사용 용도**

표현식: 값을 생성하거나 반환하는 데 사용됩니다. 변수에 할당하거나 함수의 인수로 사용할 수 있습니다.
문: 프로그램의 흐름을 제어하고 특정 작업을 수행하는 데 사용됩니다. 조건문, 반복문, 함수 선언 등이 있습니다.
독립성:

표현식: 더 큰 표현식의 일부가 될 수 있습니다.
문: 독립적으로 실행되며, 하나의 완전한 실행 단위입니다

### 12.1 함수란 ?

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.

> 함수 내부로 입력을 전발받는 변수 : 매개변수
> 입력을 : 인수
> 출력 : 반환값

### 12.2 함수를 사용하는 이유

함수는 필요할 떄 여러 번 호출할 수 있다. 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 유리하다.

코드의 중복을 억제하고, 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드이 신뢰성을 높이는 효과가 있다.

### 12.3 함수 리터럴

- 함수는 객체 타입의 값이다.
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. - 고유한 객체만의 프로퍼티를 갖는다.

### 12.4 함수 정의

함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환활 값을 지정하는 것을 말한다.

### 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

기명 함수 표현식에서는 함수 표현식에 이름을 붙입니다. 이 이름은 함수 내부에서만 유효하며, 외부에서는 접근할 수 없습니다

- 함수 선언문은 리터럴과 형태가 동일하다.
- 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다.

```js
const add = function sum(x, y) {
  return x + y;
};

console.log(add(2, 3)); // 5

// 함수 이름 'sum'은 함수 내부에서만 접근할 수 있습니다.
```

함수 표현식 할당

```js
let add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

let add = function add(x, y) { ... } 부분에서 add라는 변수에 함수 표현식을 할당하고 있습니다.
여기서 function add(x, y)는 기명 함수 표현식으로, 함수 자체에 이름 add를 붙인 것입니다.
이 함수 이름 add는 함수 내부에서만 유효합니다. 외부에서는 이 이름을 통해 함수에 접근할 수 없습니다.
외부 스코프에서의 변수 참조

외부 스코프에서는 add 변수를 통해 함수에 접근합니다. 이 add 변수는 함수 표현식의 결과를 참조하고 있습니다.
따라서, console.log(add(2, 5)) 호출은 변수 add에 저장된 함수를 호출하는 것입니다.

### 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
- 함수 표현식으로 정의한 함수는 이전에 호출할 수 없다. 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
- 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

### 12.5 함수 호출

- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다.

- 매개변수는함수 몸체 내부에서만 참조할 수 있다. 외부에서는 참조 할 수 없다.

### 반환문

함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환(return)할 수 있다.

```js
function multi(x, y) {
  return x * y; // 반환문
}

// 함수 호출은 반환값으로 평가
var result = multi(3, 5);
console.log(result); // 15
```

### 12.7 다양한 함수의 형태

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다. 한번만 호출되며 다시 호출할 수 없다.

### 콜백 함수 (Callback Function)

### 개요

콜백 함수(Callback Function)는 다른 함수의 인수로 전달되어, 특정 작업이 완료된 후 호출되는 함수입니다. 콜백 함수는 비동기 처리(예: 이벤트 처리, 타이머, AJAX 요청)나 함수의 동작을 커스터마이즈하는 데 자주 사용됩니다.

### 콜백 함수의 정의

콜백 함수는 일반 함수와 마찬가지로 정의되지만, 다른 함수의 인수로 전달됩니다.

### 예시

1. **기본적인 콜백 함수 사용 예시**:

   ```javascript
   function greet(name, callback) {
     console.log("Hello " + name);
     callback();
   }

   function sayGoodbye() {
     console.log("Goodbye!");
   }

   greet("John", sayGoodbye); // Hello John
   // Goodbye!
   ```

2. **익명 콜백 함수 사용 예시**:

   ```javascript
   function greet(name, callback) {
     console.log("Hello " + name);
     callback();
   }

   greet("John", function () {
     console.log("This is a callback function");
   }); // Hello John
   // This is a callback function
   ```

3. **비동기 처리에서의 콜백 함수**:

   ```javascript
   function fetchData(callback) {
     setTimeout(function () {
       const data = { name: "John", age: 30 };
       callback(data);
     }, 1000);
   }

   function displayData(data) {
     console.log("Data received:", data);
   }

   fetchData(displayData); // Data received: { name: 'John', age: 30 }
   ```

### 콜백 함수의 장점

1. **비동기 처리**: 콜백 함수를 사용하면 비동기 작업이 완료된 후 특정 동작을 수행할 수 있습니다.
2. **유연성**: 콜백 함수를 사용하면 함수의 동작을 동적으로 변경하거나 확장할 수 있습니다.

### 콜백 지옥 (Callback Hell)

- 콜백 함수가 중첩되어 코드의 가독성이 떨어지고 유지보수가 어려워지는 현상을 말합니다.
- 이를 해결하기 위해 **Promise**, **async/await** 패턴이 사용됩니다.

## 재귀 함수 (Recursive Function)

### 개요

재귀 함수(Recursive Function)는 자기 자신을 호출하여 반복 작업을 수행하는 함수입니다. 재귀 함수는 반복문을 사용하는 대신, 함수 내부에서 자기 자신을 호출하여 작업을 반복합니다.

### 재귀 함수의 기본 구조

재귀 함수는 두 가지 중요한 요소를 가집니다:

1. **기본 조건 (Base Case)**: 재귀 호출을 멈추기 위한 조건입니다.
2. **재귀 조건 (Recursive Case)**: 함수가 자기 자신을 호출하는 조건입니다.

### 예시

1. **팩토리얼 계산**:

   ```javascript
   function factorial(n) {
     if (n <= 1) return 1; // 기본 조건
     return n * factorial(n - 1); // 재귀 조건
   }

   console.log(factorial(5)); // 120
   ```

2. **피보나치 수열 계산**:

   ```javascript
   function fibonacci(n) {
     if (n <= 1) return n; // 기본 조건
     return fibonacci(n - 1) + fibonacci(n - 2); // 재귀 조건
   }

   console.log(fibonacci(6)); // 8
   ```

### 재귀 함수의 장점

- 복잡한 문제를 단순화하여 해결할 수 있습니다.
- 코드가 간결하고 이해하기 쉬워집니다.

### 재귀 함수의 단점

- 함수 호출 스택이 깊어지면 스택 오버플로우가 발생할 수 있습니다.
- 성능이 중요한 경우 반복문을 사용하는 것이 더 효율적일 수 있습니다.
