**# 24장 클로저**

- 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
- 클로저는 함수를 일급 객체로 사용하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

**## 24-1. 렉시컬 스코프**

- 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.
- 상위 스코프는 실행 컨텍스트의 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조' 값에 의해 결정된다.
- 이 값이 함수가 정의된 환경(위치)에 의해 결정된다. 이것을 `렉시컬 스코프`라고 한다.

**## 24-2. 함수 객체의 내부 슬롯 [[Environment]]**

- 함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장한다.
- 이때 상위스코프의 참조는 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.
- 함수 객체는 상위 스코프를 자신이 존재하는 한 기억한다.
- 함수 코드의 평가 단계에서, 함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.

**## 24-3. 클로저와 렉시컬 환경**

- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.
- 외부 함수가 중첩 함수를 return 하고 실행 컨텍스트 스택에서 사라져도, 외부 함수의 렉시컬 환경까지 소멸되는 것은 아니다.

- 그 이유는 중첩 함수의 [[Environment]] 에 의해 참조되고 있기 때문이다. 중첩 함수의 참조가 끊겨 가비지 컬렉션의 대상이 되지 않는한 살아있다.

- 중첩 함수는 상위 스코프를 참조할 수 있으므로 상위 스코프의 식별자를 참조하고 값을 변경할 수도 있다.
- 모든 함수는 상위 스코프를 참조하고 있으므로 이론적으로 모든 함수는 클로저이다. 그러나 일반적으로 클로저로 일컫어지는 것들은 조금은 다르다.
- **\*중첩 함수\*\***가 **\*상위 스코프의 식별자를 참조\*\***하고 있고 **\*중첩 함수가 외부 함수보다 더 오래 유지되는 경우\*\***에 한정하는 것이 일반적이다.

- 상위 스코프의 식별자를 참조하지 않는 함수는 클로저가 아니다.

- 중첩함수가 외부함수보다 일찍 소멸하는 함수는 클로저가 아니다. (외부함수가 중첩함수를 반환하지 않는다.)

**## 24-4. 클로저의 활용**

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

- 상태가 의도와 다르게 변경되지 않도록 안전하게 은닉한다.

- 특정 함수에게만 상태 변경을 허용한다.

**#### 전역 상태를 함수 내부 변수로 변경하는 경우**

- 전역 상태는 누구나 변경가능하고 접근가능하다. (암묵적 결합)
- 단순히 전역상태를 함수 스코프 안으로 넣어 지역 변수로 만드는 것은 은닉에는 효과적이나, 상태 유지가 되지 않는 단점이 있다.
- 클로저를 통해 상태 은닉과 특정 함수만의 상태 변경을 허용하게 할 수 있다.

**#### 보조함수를 인자로 전달받고 함수를 반환하는 고차함수 클로저**

- 이 때, 고차함수를 호출해 반환된 함수는 자신만의 독립된 렉시컬 환경을 갖는다.
- 그래서 호출할 때마다 별개의 자유변수를 갖는다. (연동되지 않는 각자의 상태)
- 만약 연동이 가능한 자유변수를 만들고자 한다면 렉시컬 환경을 공유할 수 있도록 고차함수를 1번만 호출해야한다.

**## 24-5. 캡슐화와 정보 은닉**

- 캡슐화 : 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behaviour)인 메서드를 하나로 묶는 것을 말한다.
- 정보 은닉 : 캡슐화를 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용

- 외부로부터 상태 변경을 막아, 정보를 보호

- 객체 간의 상호 의존성, 결합도를 낮추는 효과가 있음

- 대부분의 객체 지향 언어에서는 클래스를 선언하고, public, private, protected와 같은 접근 제한자를 통해 정보 은닉을 구현한다.
- 자바스크립트에서는 위와 같은 접근 제한자가 없기 때문에 이를 클로저로 간접적으로 구현한다.

- 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼수는 있다.

- 허나 완전하게 정보 은닉을 지원하지 않는다.

**## 24-6. 자주 발생하는 실수**

**#### 문제가 발생하는 상황**

- 반복문 코드블록을 사용할 때 var 키워드로 선언한 i를 함수에서 사용하여 리턴하고 호출할 때.
- var 선언 변수는 함수 레벨 스코프를 갖기 때문에 전역 변수로서 기능한다.
- 이 경우 반복문 내부에서 정의된 함수안에서 쓰이는 i는 모두 연동되어 그 상태를 공유하게 된다.
- 의도와는 다르게 함수들이 모두 같은 i를 공유한다.

**#### 해결 방법 1 : 즉시실행 & 중첩함수 리턴 [예제 24-21]**

- i를 인수로 한 즉시실행함수가 중첩함수를 리턴하게끔 한다.
- 중첩함수 내부에서는 함수 내에서는 매개변수를 활용하여 로직을 구성한다.

**#### 해결 방법 2 : let 선언변수 사용**

- let 선언변수를 사용하면 for문의 코드블록이 반복실행될 때마다 새로운 렉시컬 환경이 생성된다.
- 반복문 코드블록 내 정의된 함수가 있다면 이 함수는 새롭게 생성된 렉시컬 환경을 가리키고 있을 것이다.
- 이러한 이유로, 각 함수들은 각기 다른 식별자값을 가리킬 수 있다.

**#### 해결 방법 3 : 고차 함수 사용**

- 고차 함수는 변수와 반복문의 사용을 억제할 수 있어 오류를 줄이고 가독성을 좋게 만든다.
