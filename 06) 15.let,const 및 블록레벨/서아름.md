# 15. let, const 키워드와 블록 레벨 스코프

## 📚 var 키워드로 선언한 변수의 문제점

### 1️⃣ 변수 중복 선언 허용

```jsx
var x = 1;
var y = 1;

// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작함
var x = 100;
// 초기화문이 없는 변수 선언문은 무시됨
var y;

console.log(x); // 100
console.log(y); // 1
```

- 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작
- 초기화 문이 없는 변수 선언문은 무시 → 에러 발생 ❌
- 동일한 이름의 변수를 중복 선언하여 값까지 할당한 경우, 의도치 않게 먼저 선언된 변수 값이 변경됨 !

<br />

### 2️⃣ 함수 레벨 스코프

```jsx
var x = 1;

if (true) {
  // x는 전역 변수 -> 중복 선언 -> 의도치 않은 변수 값 변경 유발
  var x = 10;
}

console.log(x); // 10
```

```jsx
var i = 10;

// for의 i는 이미 위에서 선언된 전역 변수 -> 중복 선언 -> 의도치 않은 변수 값 변경 유발
for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i);
```

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정

- 함수 외부에서 var 키워드로 선언한 변수는 **코드 블록 내에서 선언해도 모두 전역 변수**가 됨
- 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높임 → 의도치 않은 전역 변수 중복 선언

  > **함수 레벨 스코프**: 함수 내부에서 선언한 변수는 지역 변수, 함수 외부에서 선언한 변수는 모두 전역 변수

  > **블록 레벨 스코프**: 모든 코드블록(함수, if 문, for 문, while 문 등) 내에서 선언한 변수는 모두 지역 변수 (코드 블록 내에서만 유효), 코드블록 외부에서 내부 참조 불가

<br />

### 3️⃣ 변수 호이스팅

```jsx
// 1. 선언 단계: 이 시점에 변수 호이스팅에 의해 이미 변수 foo 선언
// 2. 초기화 단계: 변수 할당문 이전에 참조했기 때문에 undefined로 초기화
console.log(foo); // undefined

// 3. 할당 단계: 변수 값 할당
foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적 실행
var foo;
```

- var 키워드로 선언한 변수는 변수 선언문 이전에 참조 가능
- 단, 할당문 이전에 변수 참조 시, 언제나 undefined 반환
- 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만, 프로그램 흐름 상 맞지 않고 가독성 저하 및 오류 발생 가능성 증가

<br />

## 📚 let 키워드

### 1️⃣ 변수 중복 선언 금지

```jsx
var foo = 123;

// 같은 스코프 내에서의 중복 선언 허용 (자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 행동)
var foo = 456;

let bar = 123;

// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언 불가
let bar = 456; // SyntaxError: Identifier 'bar' has already been declared
```

- let 키워드로 이름이 같은 변수 중복 선언 시, 문법 에러(SyntaxError) 발생

<br />

### 2️⃣ 블록 레벨 스코프

```jsx
let foo = 1; // 전역 변수

{
  let foo = 2; // 지역 변수
  let bar = 3; // 지역 변수
}

console.log(foo); // 1
console.log(bar); // ReferenceError: bar is not defined
```

- 모든 코드 블록(함수, if 문, for 문, while 문 등)을 지역 스코프로 인정
- **함수 내의 코드 블록은 함수 레벨 스코프에 중첩**됨

<br />

### 3️⃣ 변수 호이스팅

```jsx
console.log(foo); // ReferenceError: foo is not defined
let foo;
```

- let 키워드로 선언한 변수는 `변수 호이스팅이 발생하지 않는 것처럼` 동작

- var 키워드와 달리, **선언 단계와 초기화 단계가 분리**되어 진행
  - 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행
  - 초기화 단계는 변수 선언문에 도달했을 때 실행
  - 초기화 단계가 실행되기 전에 변수 접근 시, 참조 에러(ReferenceError) 발생
  - 즉, 스코프의 시작 지점부터 초기화 단계 시작 시점(변수 선언문)까지 변수 참조 불가능 ❌
- 일시적 사각지대
  - 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

<br />

```jsx
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

- let 키워드는 변수 호이스팅이 발생하지 않는 것처럼 보임

- 변수 호이스팅이 발생하지 않는다면, 전역 변수 foo의 값을 출력해야 함
- let 키워드로 선언한 변수도 **여전히 호이스팅이 발생**하기 때문에 참조 에러(ReferenceError)가 발생함
  - 호이스팅으로 인해 지역 변수 foo를 참조하고 있음

<br />

### 4️⃣ 전역 객체와 let

```jsx
// 전역 변수
var x = 1;
// 암묵적 전역
y = 2;
// 전역 함수
function foo() {}

// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티
console.log(window.x); // 1

// 전역 객체 winodw의 프로퍼티는 전역 변수처럼 사용 가능
console.log(x); // 1

// 암묵적 전역은 window의 프로퍼티
console.log(window.y); // 2
console.log(y);

// 함수 선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티
console.log(window.foo); // f foo() {}
// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용 가능
console.log(foo); // f foo() {}
```

- var 키워드로 선언한 전역 변수, 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 됨
- 전역 객체의 프로퍼티 참조 시, window 생략 가능

```jsx
let x = 1;

// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아님
console.log(window.x); // undefined
console.log(x); // 1
```

- **let 키워드**로 선언한 전역 변수는 **전역 객체의 프로퍼티가 아님** ❌
- let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재함

  > **전역 렉시컬 환경 레코드의 선언적 환경 레코드**: let, const 키워드로 선언한 전역 변수가 전역 객체의 프로퍼티가 되지 않고 존재하는 블록

  <br />

<hr />

- `참고`

  [ **전역 환경 레코드** ]

  - 객체 환경 레코드와 선언적환경 레코드로 구성

  [ **객체 환경 레코드** ]

  - 기존 전역 개체가 관리하던 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 관리

  - BindingObject라고 부르는 객체와 연결됨
    - BindingObject: 전역 객체 생성에서 생성된 전역 객체
  - 전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 .BindingObject를 통해 전역 객체의 프로퍼티와 메소드가 됨
  - **변수** 호이스팅
    1. 전역 코드 평가 시점에 객체 환경 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록
    2. 암묵적으로 undefined 바인딩
    3. var 키워드로 선언한 변수는 코드 실행 단계에서 변수 선언문 이전에도 참조 가능 (단, 변수 할당 이전에 참조한 값은 언제나 undefined)
    4. var 키워드로 선언한 변수에 할당한 함수 표현식도 이와 동일하게 동작
  - **함수** 호이스팅
    1. 함수 선언문으로 정의한 함수 평가
    2. 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 키로 등록
    3. 생성된 함수 객체를 즉시 할당 → 함수 선언문으로 정의한 함수는 선언문 이전에 호출 가능 !!
       [ **선언적 환경 레코드** ]
  - let, const 키워드로 선언한 전역 변수를 관리
  - let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재, 이때 블록이 전역 렉시컬 환경 레코드의 선언적 환경 레코드
  - 전역 객체의 프로퍼티가 되지 않기 때문에, 전역 객체 프로퍼티(window) 참조 불가
  - 선언과 초기화 단계가 분리되어 진행 → 런타임 실행 흐름이 변수 선언문에 도달하기 전까지 일시적 사각지대(TDZ)에 빠짐
    - 일시적 사각지대(TDZ): 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

<br />

## 📚 const 키워드

- 주로 상수 선언 시 사용

### 🔖 선언과 초기화

```jsx
const foo = 1;

const bar; // SyntaxError: Missing initializer in const declaration
```

- const 키워드로 선언한 변수는 `반드시 선언과 동시에 초기화`해야 함

```jsx
{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  const foo = 1;
  console.log(foo); // 1
}

console.log(foo); // ReferenceError: foo is not defined
```

- let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작함

<br />

### 🔖 재할당 금지

```jsx
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

- const 키워드로 선언한 변수는 재할당 금지

<br />

### 🔖 상수

- const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없기 때문에, 상수 표현에 사용됨

- 상수도 메모리 공간이 필요하기 때문에, 변수라고 할 수 있음
- `변수`는 언제든지 **재할당**을 통해 `변수 값 변경 가능`
- `상수`는 `재할당 금지` 🚫
- 상수 이름은 대문자, 스네이크 케이스로 표현

<br />

### 🔖 const 키워드와 객체

```jsx
const person = {
  name: "Lee",
};

// 객체는 변경 가능한 값이기 때문에, 재할당 없이 변경 가능
person.name = "Kim";

console.log(person);
```

- const 키워드로 선언된 변수에 객체를 할당한 경우 값 변경 가능

- 객체는 재할당 없이도 직접 변경 가능
- const 키워드는 재할당을 금지할 뿐, **“불변”을 의미하지는 않음** ❌
- **객체가 변경**되더라도 변수에 **할당된 참조 값은 변경되지 않음** ❌ !!

<br />

## 📚 var vs let vs const

> 일단 const 키워드 사용 후, 재할당이 필요하다면 let 키워드로 변경할 것을 추천 !!

[ **var** ]

- ES6에서는 사용하지 않는 키워드

[ **let** ]

- 재할당이 필요한 경우 한정해서 사용하는 것을 추천
- 변수 스코프는 최대한 작게 만들 것

[ **const** ]

- 변수 선언에 기본적으로 사용
- 의도치 않은 재할당을 방지하기 때문에 안전
- 변경없이 읽기 전용으로 사용하는 원시 값과 객체에 사용
